<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta name="generator" content="HTML Tidy for HTML5 for Linux version 5.8.0" />
  <title>fLisp Embedding and Development</title>
  <meta content="text/html; charset=utf-8" http-equiv="content-type" />
  <meta content="Emacs, editor, Lisp, tiny, reference, manual" name="keywords" />
  <meta content="Embedding fLisp in other application, fLisp internals and development" name="description" />
  <meta content="Georg Lehner &lt;jorge@magma-soft.at&gt;" name="author" />
  <meta content="2023" name="copyright" />
</head>
<body>
  <h1>Development of and with <i>fLisp</i></h1>
  <h3 id="introduction">Introduction</h3>
  <p>This document explains how to extend and embed&nbsp;<var>fLisp</var> into an application.</p>
  <p>Other documentation topics:</p>
  <ul>
    <li>
      <a href="flisp.html"><i>fLisp</i> Manual</a>&nbsp;<a href="flisp.md">(Markdown)</a>
    </li>
    <li>
      <a href="history.html">History</a>&nbsp;(<a href="history.md">Markdown</a>)
    </li>
    <li>
      <a href="implementation.html">Implementation</a>&nbsp;Details (<a href="markdown.md">Markdown</a>)
    </li>
  </ul>
  <h3 id="toc">Table of Contents</h3>
  <ol>
    <li>
      <a href="#introduction">Introduction</a>
    </li>
    <li>Table of Contents</li>
    <li>
      <a href="#embedding">Embedding Overview</a>
    </li>
    <li>
      <a href="#c_api">fLisp C Interface</a>
    </li>
    <li>
      <a href="#extensions">Building Extensions</a>
    </li>
  </ol>
  <h3 id="embed_overview">Embedding Overview</h3>
  <p><i>fLisp</i> can be embedded into a C application. Two examples of embedding are the <a href=
  "https://github.com/jorge-leon/femto">Femto text editor</a>&nbsp; and the&nbsp;<code>flisp</code> command line Lisp
  interpreter. This provides access from the application to the Lisp language features.</p>
  <p>In order to get access from the Lisp interpreter to the application extensions to <i>fLisp</i> have to be
  implemented. These consist in C function with a specific signature and which must return a Lisp object.&nbsp;C macros
  facilitate introspection and access to the arguments. The C functions are registered with an <i>fLisp</i> interpreter
  with the <code>flisp_register_primitive()</code> function.</p>
  <p>Two extensions are already provided with <i>fLisp</i>. The&nbsp;<i>file</i> extension gives access to the
  operating system features, exposing some POSIX functions to <i>fLisp</i>. If floating point arithmetic is required
  the <i>double</i> extension can be used. The extensions are described in the <i>fLisp</i> manual.</p>
  <p>Operating the <var>fLisp</var> interpreter in an application involves the following steps:</p>
  <ol>
    <li>Creation of an <i>fLisp</i> interpreter with <code>flisp_new()</code>.</li>
    <li>Optional loading of extensions into the interpreter.</li>
    <li>Optional loading of Lisp libraries into the interpreter.</li>
    <li>Evaluation/execution of Lisp commands with <code>flisp_eval()</code>.</li>
  </ol>
  <p>Different flows of operation can be implemented. For example the Femto editor initializes the interpreter without
  input/output file descriptors and sends strings of Lisp commands to the interpreter, either when a key is pressed or
  upon explicit request via the editor user interface. Another example is the&nbsp;<code>flisp</code> command line
  interpreter which sets <code>stdout</code> as the default output file descriptors of the <i>fLisp</i> interpreter and
  loads a startup script which implements a read eval print loop, reading from <code>stdin</code> - thus creating it's
  own user interface.</p>
  <p>Lisp commands (or programs) are handed over to the&nbsp;<code>flisp_eval()</code> function as strings. The input
  is processed within a&nbsp;<a href="interp_ops"><code>catch</code></a>&nbsp;command and the result stored in its
  internal structure. C macros are provided for easy access to the result.</p>
  <h3>fLisp C Interface</h3>
  <p><i>fLisp</i> exposes the following public interface functions:</p>
  <dl>
    <dt><code>flisp_new()</code></dt>
    <dd>Create a new interpreter.</dd>
    <dt><code>flisp_destroy()</code></dt>
    <dd>Destroy an interpreter, releasing resources.</dd>
    <dt><code>flisp_eval()</code></dt>
    <dd>Evaluate a string or the input stream until exhausted or error.</dd>
    <dt><code>flisp_write_object()</code></dt>
    <dd>Format and write object to file descriptor.</dd>
    <dt><code>flisp_write_error()</code></dt>
    <dd>Format and write the error object and error message of an interpreter to a file descriptor.</dd>
    <dt><code>flisp_register_constant()</code></dt>
    <dd>Register a global symbol binding.</dd>
    <dt><code>flisp_register_primitive()</code></dt>
    <dd>Register an extension <i>fLisp</i> function.</dd>
  </dl>
  <h4>Interpreter creation</h4>
  <p>A new <i>fLisp</i> interpreter is created with the function <code>flisp_new()</code>. Upon success a pointer to an
  initialized <i>Interpreter</i> structure is returned, which is required for all other <i>fLisp</i> operations. If the
  required memory for the interpreter cannot be allocated a <code>NULL</code> pointer is returned instead.</p>
  <p><code>flisp_new()</code> registers the interpreter in a circular single linked list stored in the global variable
  <code>flisp_interpreters</code>.</p>
  <p><mark>Note: currently only creating one interpreter has been tested.</mark></p>
  <p>The signature of <code>flisp_new()</code> is:</p>
  <blockquote>
    <code>Interpreter *flisp_new(site_t <var>size</var>, char **<var>argv</var>, char *<var>library_path</var>, FILE
    *<var>input</var>, FILE *<var>output</var>, FILE* <var>debug</var>)</code>
  </blockquote>
  <dl>
    <dt><code><var>size</var></code></dt>
    <dd>Initial memory size to allocate for the Lisp object space in bytes. If size is zero, the Lisp interpreter will
    allocate memory whenever needed.</dd>
    <dt><code><var>argv</var></code></dt>
    <dd>
      <p>If not <code>NULL</code> the <i>fLisp</i> root environment is initialized with the following symbols:</p>
      <p><var>argv0</var> .. bound to&nbsp;the string stored in <code>*<var>argv</var>[0]</code></p>
      <p><var>argv ..&nbsp;</var>The list of strings stored in <code><var>argv</var></code></p>
    </dd>
    <dt><var>library_path</var></dt>
    <dd>
      <dl>
        <dd>If not <code>NULL</code> the <i>fLisp</i> root environment is initialized with the
        symbol&nbsp;<var>script_dir</var>&nbsp;bound to the string stored in <code><var>library_path</var></code>.</dd>
      </dl>
    </dd>
    <dt><var>input</var></dt>
    <dd>Default input stream. If <var>input</var> is&nbsp;<code>NULL</code>&nbsp;no&nbsp;<i>fLisp</i> input stream is
    set up.</dd>
    <dt><var>output</var></dt>
    <dd>Default output stream. If <var>output</var> is&nbsp;<code>NULL</code> a memory stream is created at the first
    invocation of the interpreter and set as the default output stream.</dd>
    <dt><var>debug</var></dt>
    <dd>Debug output stream. If set to <code>NULL</code> no debug information is generated.</dd>
  </dl>
  <p>The Lisp interpreter allocates new object space in chunks of eight kilobytes (by default) whenever a garbage
  collection cycle does not free sufficient memory. This happens mainly during startup, when initial libraries are
  loaded or commands are executed for the first time. It is recommended to use the debug output to determine the final
  amount required by an application and initialize the interpreter with a corresponding <var>size</var> argument.</p>
  <p><var>argv</var>&nbsp;is meant to be set to the applications <var>argv</var> vector, however it can be set to any
  other array of strings if needed.</p>
  <h4>Interpreter execution</h4>
  <p>The signature of <code>flisp_eval()</code> is:</p>
  <blockquote>
    <p><code>void&nbsp;lisp_eval(Interpreter&nbsp;*<var>interp</var>, char&nbsp;*<var>string</var>)</code></p>
  </blockquote>
  <p>If <var>string</var> is not <code>NULL</code> all Lisp expressions in <var>string</var>&nbsp;are evaluated
  sequentually in the interpreter <var>interp</var>.</p>
  <p>If <var>string</var> is <code>NULL</code> the&nbsp;&nbsp;input stream&nbsp;of the <i>fLisp</i> interpreter
  <var>interp</var> is evaluated until end of file.</p>
  <p>If no memory can be allocated for the input string or the input file descriptor is <code>NULL</code> no Lisp
  evaluation takes place and the result is a corresponing error result.</p>
  <p>After processing the input, the interpreter holds the results corresponding to a <a href=
  "interp_ops"><code>catch</code></a> result in its internal structure. They can be accessed with the following
  C-macros:</p>
  <dl>
    <dt><var>error_type</var></dt>
    <dd><code>FLISP_RESULT_CODE(interpreter)</code></dd>
    <dt><var>message</var></dt>
    <dd><code>FLISP_RESULT_MESSAGE(interpreter)</code></dd>
    <dt><var>object</var></dt>
    <dd><code>FLISP_RESULT_OBJECT(interpreter)</code></dd>
  </dl>
  <p>Check for <code>(FLISP_RESULT_OBJECT(interpreter) != nil)</code> to find out if the result is an error. Then check
  for <code>(FLISP_RESULT_OBJECT(interpreter) == out_of_memory)</code> to see if a fatal condition occured.</p>
  <p>On error use <code>lisp_write_error()</code> to write the standard error message to a file descriptor of choice,
  or use the above C-macros and <code>FLISP_ERROR_MESSAGE(interpreter)-&gt;string</code> for executing a specific
  action.</p>
  <p><i>fLisp</i> sends all output to the default output stream. If it is set to <code>NULL</code> on initialization,
  output is suppressed altogether.</p>
  <h4 id="c_api">fLisp C Interface</h4>
  <dl>
    <dt>&nbsp;</dt>
    <dd></dd>
    <dt><code>void&nbsp;lisp_destroy(Interpreter&nbsp;*<var>interp</var>)</code></dt>
    <dd>Frees all resources used by the interpreter.</dd>
    <dt>&nbsp;</dt>
    <dt><code>void&nbsp;lisp_write_object(Interpreter&nbsp;*<var>interp</var>, FILE&nbsp;<var>*fd</var>,
    Object&nbsp;*<var>object</var>, bool&nbsp;readably)</code></dt>
    <dd>Format <var>object</var> into a string and write it to <var>stream</var>. If <var>readably</var> is true, the
    string can be read in by the interpreter and results in the same object.</dd>
    <dt><code>void&nbsp;lisp_write_error(Interpreter&nbsp;*<var>interp</var>, FILE&nbsp;<var>*fd</var>)</code></dt>
    <dd>Format the error <var>object</var> and the error message of the interpreter into a string and write it to
    <var>fd</var>. The <var>object</var> is written with <var>readably</var> <code>true</code>.</dd>
  </dl>
  <p>&nbsp;</p>
  <h3 id="extensions">Building Extensions</h3>
  <p>An extensions has to create C functions with the signature:
  <code>Object&nbsp;*<var>primitive</var>(Interpreter&nbsp;*interp, Object&nbsp;**args, Object&nbsp;**env)</code>,
  where <var>primitive</var> is a distinct name in C space. This function has to be added to the global variable
  <code>primitives</code> in the following format:
  <code>{"<var>name</var>",&nbsp;<var>argMin</var>,&nbsp;<var>argMax</var>,&nbsp;<var>type_check</var>,&nbsp;<var>primitive</var>}</code>.
  Here <var>name</var> is a distinct name in Lisp space.</p>
  <p><var>interp</var> is the fLisp interpreter in which <var>primitive</var> is executed. <var>argMin</var> is the
  minimum number of arguments, <var>argMax</var> is the maximum number of arguments allowed for the function. If
  <var>argMax</var> is a negative number, arguments must be given in tuples of <var>argMax</var> and the number of
  tuples is not restricted.</p>
  <p>When type check is set to on of the <code>TYPE_*</code> C-macros the interpreter assures that all arguments are of
  the given type and creates a standardized exception otherwise. When type check is set to <code>0</code> the primitive
  has to take care of type checking by itself. The C-macro <code>CHECK_TYPE</code> helps with this.</p>
  <p>When creating more then one new objects within a primitive, care has to be taken to register them with the garbage
  collector. Registration is started with the <code>GC_CHECKPOINT</code> CPP macro.
  <code>GC_TRACE(<var>name</var>,&nbsp;<var>value</var></code> creates an object variable <var>name</var>, sets it to
  <var>value</var> and registers it with the garbage collector. The macro <code>GC_RELEASE</code> must be called to
  finalize the registration. The convenience macro <code>GC_RETURN(<var>object</var>)</code> calls
  <code>GC_RELEASE</code> and returns <var>object</var>.</p>
  <p>Some CPP macros are provided to simplify argument access and validation in primitives:</p>
  <dl>
    <dt><code>FLISP_HAS_ARGS</code></dt>
    <dt><code>FLISP_HAS_ARG_TWO</code></dt>
    <dt><code>FLISP_HAS_ARG_THREE</code></dt>
    <dd>Evaluate to true if there are arguments or the respective argument is available.</dd>
    <dt><code>FLISP_ARG_ONE</code></dt>
    <dt><code>FLISP_ARG_TWO</code></dt>
    <dt><code>FLISP_ARG_THREE</code></dt>
    <dd>Evaluate to the respective argument.</dd>
    <dt><code>CHECK_TYPE(<var>argument</var>, <var>type</var>, <var>signature</var>)</code></dt>
    <dd>Assures that the given argument is of the given type. <var>type</var> must be a type variable like
    <code>type_string</code>. <var>signature</var> is the signature of the primitive followed by
    <q><code>&nbsp;-&nbsp;</code></q> and the name of the argument to be type checked. This is used to form a
    standardized <code>wrong-type-argument</code> error message.</dd>
  </dl>
  <nav>
    <a href="#toc">^</a>
  </nav>
  <p><!--
    Emacs:
    Local Variables:
    fill-column: 120
    End:
  --></p>
</body>
</html>
